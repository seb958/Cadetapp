diff --git a/backend_test.py b/backend_test.py
new file mode 100644
index 0000000..e8b2461
--- /dev/null
+++ b/backend_test.py
@@ -0,0 +1,524 @@
+#!/usr/bin/env python3
+"""
+Tests complets pour le syst√®me d'authentification de l'application escadron de cadets
+Teste tous les endpoints d'authentification, permissions et gestion des utilisateurs
+"""
+
+import requests
+import json
+import time
+from datetime import datetime
+import sys
+
+# Configuration
+BASE_URL = "https://cadetron.preview.emergentagent.com/api"
+
+# Comptes de test existants
+ADMIN_EMAIL = "admin@escadron.fr"
+ADMIN_PASSWORD = "admin123"
+CADET_EMAIL = "cadet.test@escadron.fr"
+CADET_PASSWORD = "cadet123"
+
+class AuthenticationTester:
+    def __init__(self):
+        self.admin_token = None
+        self.cadet_token = None
+        self.admin_user = None
+        self.cadet_user = None
+        self.test_results = []
+        self.invitation_token = None
+        self.new_user_email = f"test.invite.{int(time.time())}@escadron.fr"
+        
+    def log_test(self, test_name, success, details=""):
+        """Enregistre le r√©sultat d'un test"""
+        status = "‚úÖ PASS" if success else "‚ùå FAIL"
+        print(f"{status} - {test_name}")
+        if details:
+            print(f"    Details: {details}")
+        self.test_results.append({
+            "test": test_name,
+            "success": success,
+            "details": details,
+            "timestamp": datetime.now().isoformat()
+        })
+        
+    def test_api_health(self):
+        """Test de base - v√©rifier que l'API r√©pond"""
+        try:
+            response = requests.get(f"{BASE_URL}/", timeout=10)
+            if response.status_code == 200:
+                data = response.json()
+                self.log_test("API Health Check", True, f"Message: {data.get('message', 'N/A')}")
+                return True
+            else:
+                self.log_test("API Health Check", False, f"Status: {response.status_code}")
+                return False
+        except Exception as e:
+            self.log_test("API Health Check", False, f"Erreur: {str(e)}")
+            return False
+    
+    def test_admin_login(self):
+        """Test de connexion administrateur"""
+        try:
+            payload = {
+                "email": ADMIN_EMAIL,
+                "password": ADMIN_PASSWORD
+            }
+            response = requests.post(f"{BASE_URL}/auth/login", json=payload, timeout=10)
+            
+            if response.status_code == 200:
+                data = response.json()
+                if "access_token" in data and "user" in data:
+                    self.admin_token = data["access_token"]
+                    self.admin_user = data["user"]
+                    user_role = self.admin_user.get("role", "unknown")
+                    self.log_test("Login Admin", True, f"Token re√ßu, R√¥le: {user_role}")
+                    return True
+                else:
+                    self.log_test("Login Admin", False, "Token ou utilisateur manquant dans la r√©ponse")
+                    return False
+            else:
+                self.log_test("Login Admin", False, f"Status: {response.status_code}, Response: {response.text}")
+                return False
+        except Exception as e:
+            self.log_test("Login Admin", False, f"Erreur: {str(e)}")
+            return False
+    
+    def test_cadet_login(self):
+        """Test de connexion cadet"""
+        try:
+            payload = {
+                "email": CADET_EMAIL,
+                "password": CADET_PASSWORD
+            }
+            response = requests.post(f"{BASE_URL}/auth/login", json=payload, timeout=10)
+            
+            if response.status_code == 200:
+                data = response.json()
+                if "access_token" in data and "user" in data:
+                    self.cadet_token = data["access_token"]
+                    self.cadet_user = data["user"]
+                    user_role = self.cadet_user.get("role", "unknown")
+                    self.log_test("Login Cadet", True, f"Token re√ßu, R√¥le: {user_role}")
+                    return True
+                else:
+                    self.log_test("Login Cadet", False, "Token ou utilisateur manquant dans la r√©ponse")
+                    return False
+            else:
+                self.log_test("Login Cadet", False, f"Status: {response.status_code}, Response: {response.text}")
+                return False
+        except Exception as e:
+            self.log_test("Login Cadet", False, f"Erreur: {str(e)}")
+            return False
+    
+    def test_invalid_login(self):
+        """Test avec des identifiants invalides"""
+        try:
+            payload = {
+                "email": "invalid@test.com",
+                "password": "wrongpassword"
+            }
+            response = requests.post(f"{BASE_URL}/auth/login", json=payload, timeout=10)
+            
+            if response.status_code == 401:
+                self.log_test("Login Invalide", True, "Erreur 401 correctement retourn√©e")
+                return True
+            else:
+                self.log_test("Login Invalide", False, f"Status attendu: 401, re√ßu: {response.status_code}")
+                return False
+        except Exception as e:
+            self.log_test("Login Invalide", False, f"Erreur: {str(e)}")
+            return False
+    
+    def test_get_current_user_admin(self):
+        """Test r√©cup√©ration profil utilisateur admin"""
+        if not self.admin_token:
+            self.log_test("Get Current User Admin", False, "Token admin non disponible")
+            return False
+            
+        try:
+            headers = {"Authorization": f"Bearer {self.admin_token}"}
+            response = requests.get(f"{BASE_URL}/auth/me", headers=headers, timeout=10)
+            
+            if response.status_code == 200:
+                data = response.json()
+                if data.get("email") == ADMIN_EMAIL:
+                    self.log_test("Get Current User Admin", True, f"Profil r√©cup√©r√©: {data.get('prenom')} {data.get('nom')}")
+                    return True
+                else:
+                    self.log_test("Get Current User Admin", False, "Email ne correspond pas")
+                    return False
+            else:
+                self.log_test("Get Current User Admin", False, f"Status: {response.status_code}")
+                return False
+        except Exception as e:
+            self.log_test("Get Current User Admin", False, f"Erreur: {str(e)}")
+            return False
+    
+    def test_get_current_user_cadet(self):
+        """Test r√©cup√©ration profil utilisateur cadet"""
+        if not self.cadet_token:
+            self.log_test("Get Current User Cadet", False, "Token cadet non disponible")
+            return False
+            
+        try:
+            headers = {"Authorization": f"Bearer {self.cadet_token}"}
+            response = requests.get(f"{BASE_URL}/auth/me", headers=headers, timeout=10)
+            
+            if response.status_code == 200:
+                data = response.json()
+                if data.get("email") == CADET_EMAIL:
+                    self.log_test("Get Current User Cadet", True, f"Profil r√©cup√©r√©: {data.get('prenom')} {data.get('nom')}")
+                    return True
+                else:
+                    self.log_test("Get Current User Cadet", False, "Email ne correspond pas")
+                    return False
+            else:
+                self.log_test("Get Current User Cadet", False, f"Status: {response.status_code}")
+                return False
+        except Exception as e:
+            self.log_test("Get Current User Cadet", False, f"Erreur: {str(e)}")
+            return False
+    
+    def test_protected_route_without_token(self):
+        """Test acc√®s route prot√©g√©e sans token"""
+        try:
+            response = requests.get(f"{BASE_URL}/auth/me", timeout=10)
+            
+            if response.status_code == 403:
+                self.log_test("Route Prot√©g√©e Sans Token", True, "Acc√®s refus√© correctement (403)")
+                return True
+            else:
+                self.log_test("Route Prot√©g√©e Sans Token", False, f"Status attendu: 403, re√ßu: {response.status_code}")
+                return False
+        except Exception as e:
+            self.log_test("Route Prot√©g√©e Sans Token", False, f"Erreur: {str(e)}")
+            return False
+    
+    def test_create_invitation_admin(self):
+        """Test cr√©ation d'invitation par admin"""
+        if not self.admin_token:
+            self.log_test("Cr√©ation Invitation Admin", False, "Token admin non disponible")
+            return False
+            
+        try:
+            headers = {"Authorization": f"Bearer {self.admin_token}"}
+            payload = {
+                "email": self.new_user_email,
+                "nom": "TestInvite",
+                "prenom": "Utilisateur",
+                "grade": "cadet",
+                "role": "cadet"
+            }
+            response = requests.post(f"{BASE_URL}/auth/invite", json=payload, headers=headers, timeout=10)
+            
+            if response.status_code == 200:
+                data = response.json()
+                if "token" in data:
+                    self.invitation_token = data["token"]
+                    self.log_test("Cr√©ation Invitation Admin", True, f"Invitation cr√©√©e pour {self.new_user_email}")
+                    return True
+                else:
+                    self.log_test("Cr√©ation Invitation Admin", False, "Token d'invitation manquant")
+                    return False
+            else:
+                self.log_test("Cr√©ation Invitation Admin", False, f"Status: {response.status_code}, Response: {response.text}")
+                return False
+        except Exception as e:
+            self.log_test("Cr√©ation Invitation Admin", False, f"Erreur: {str(e)}")
+            return False
+    
+    def test_create_invitation_cadet_forbidden(self):
+        """Test cr√©ation d'invitation par cadet (doit √™tre refus√©e)"""
+        if not self.cadet_token:
+            self.log_test("Invitation Cadet Interdite", False, "Token cadet non disponible")
+            return False
+            
+        try:
+            headers = {"Authorization": f"Bearer {self.cadet_token}"}
+            payload = {
+                "email": f"forbidden.{int(time.time())}@escadron.fr",
+                "nom": "Forbidden",
+                "prenom": "Test",
+                "grade": "cadet",
+                "role": "cadet"
+            }
+            response = requests.post(f"{BASE_URL}/auth/invite", json=payload, headers=headers, timeout=10)
+            
+            if response.status_code == 403:
+                self.log_test("Invitation Cadet Interdite", True, "Acc√®s refus√© correctement pour cadet")
+                return True
+            else:
+                self.log_test("Invitation Cadet Interdite", False, f"Status attendu: 403, re√ßu: {response.status_code}")
+                return False
+        except Exception as e:
+            self.log_test("Invitation Cadet Interdite", False, f"Erreur: {str(e)}")
+            return False
+    
+    def test_set_password_with_invitation_token(self):
+        """Test d√©finition mot de passe avec token d'invitation"""
+        if not self.invitation_token:
+            self.log_test("D√©finition Mot de Passe", False, "Token d'invitation non disponible")
+            return False
+            
+        try:
+            payload = {
+                "token": self.invitation_token,
+                "password": "nouveaumotdepasse123"
+            }
+            response = requests.post(f"{BASE_URL}/auth/set-password", json=payload, timeout=10)
+            
+            if response.status_code == 200:
+                self.log_test("D√©finition Mot de Passe", True, "Mot de passe d√©fini avec succ√®s")
+                return True
+            else:
+                self.log_test("D√©finition Mot de Passe", False, f"Status: {response.status_code}, Response: {response.text}")
+                return False
+        except Exception as e:
+            self.log_test("D√©finition Mot de Passe", False, f"Erreur: {str(e)}")
+            return False
+    
+    def test_login_with_new_account(self):
+        """Test connexion avec le nouveau compte cr√©√©"""
+        try:
+            payload = {
+                "email": self.new_user_email,
+                "password": "nouveaumotdepasse123"
+            }
+            response = requests.post(f"{BASE_URL}/auth/login", json=payload, timeout=10)
+            
+            if response.status_code == 200:
+                data = response.json()
+                if "access_token" in data:
+                    self.log_test("Login Nouveau Compte", True, f"Connexion r√©ussie pour {self.new_user_email}")
+                    return True
+                else:
+                    self.log_test("Login Nouveau Compte", False, "Token manquant")
+                    return False
+            else:
+                self.log_test("Login Nouveau Compte", False, f"Status: {response.status_code}, Response: {response.text}")
+                return False
+        except Exception as e:
+            self.log_test("Login Nouveau Compte", False, f"Erreur: {str(e)}")
+            return False
+    
+    def test_get_users_admin(self):
+        """Test r√©cup√©ration liste utilisateurs par admin"""
+        if not self.admin_token:
+            self.log_test("Liste Utilisateurs Admin", False, "Token admin non disponible")
+            return False
+            
+        try:
+            headers = {"Authorization": f"Bearer {self.admin_token}"}
+            response = requests.get(f"{BASE_URL}/users", headers=headers, timeout=10)
+            
+            if response.status_code == 200:
+                data = response.json()
+                if isinstance(data, list):
+                    self.log_test("Liste Utilisateurs Admin", True, f"{len(data)} utilisateurs trouv√©s")
+                    return True
+                else:
+                    self.log_test("Liste Utilisateurs Admin", False, "R√©ponse n'est pas une liste")
+                    return False
+            else:
+                self.log_test("Liste Utilisateurs Admin", False, f"Status: {response.status_code}")
+                return False
+        except Exception as e:
+            self.log_test("Liste Utilisateurs Admin", False, f"Erreur: {str(e)}")
+            return False
+    
+    def test_get_users_cadet_forbidden(self):
+        """Test r√©cup√©ration liste utilisateurs par cadet (doit √™tre refus√©e)"""
+        if not self.cadet_token:
+            self.log_test("Liste Utilisateurs Cadet Interdite", False, "Token cadet non disponible")
+            return False
+            
+        try:
+            headers = {"Authorization": f"Bearer {self.cadet_token}"}
+            response = requests.get(f"{BASE_URL}/users", headers=headers, timeout=10)
+            
+            if response.status_code == 403:
+                self.log_test("Liste Utilisateurs Cadet Interdite", True, "Acc√®s refus√© correctement pour cadet")
+                return True
+            else:
+                self.log_test("Liste Utilisateurs Cadet Interdite", False, f"Status attendu: 403, re√ßu: {response.status_code}")
+                return False
+        except Exception as e:
+            self.log_test("Liste Utilisateurs Cadet Interdite", False, f"Erreur: {str(e)}")
+            return False
+    
+    def test_create_section_admin(self):
+        """Test cr√©ation de section par admin"""
+        if not self.admin_token:
+            self.log_test("Cr√©ation Section Admin", False, "Token admin non disponible")
+            return False
+            
+        try:
+            headers = {"Authorization": f"Bearer {self.admin_token}"}
+            payload = {
+                "nom": f"Section Test {int(time.time())}",
+                "description": "Section cr√©√©e pour les tests automatis√©s"
+            }
+            response = requests.post(f"{BASE_URL}/sections", json=payload, headers=headers, timeout=10)
+            
+            if response.status_code == 200:
+                data = response.json()
+                if "id" in data and "nom" in data:
+                    self.log_test("Cr√©ation Section Admin", True, f"Section cr√©√©e: {data['nom']}")
+                    return True
+                else:
+                    self.log_test("Cr√©ation Section Admin", False, "Donn√©es de section manquantes")
+                    return False
+            else:
+                self.log_test("Cr√©ation Section Admin", False, f"Status: {response.status_code}, Response: {response.text}")
+                return False
+        except Exception as e:
+            self.log_test("Cr√©ation Section Admin", False, f"Erreur: {str(e)}")
+            return False
+    
+    def test_get_sections(self):
+        """Test r√©cup√©ration liste des sections"""
+        if not self.admin_token:
+            self.log_test("Liste Sections", False, "Token admin non disponible")
+            return False
+            
+        try:
+            headers = {"Authorization": f"Bearer {self.admin_token}"}
+            response = requests.get(f"{BASE_URL}/sections", headers=headers, timeout=10)
+            
+            if response.status_code == 200:
+                data = response.json()
+                if isinstance(data, list):
+                    self.log_test("Liste Sections", True, f"{len(data)} sections trouv√©es")
+                    return True
+                else:
+                    self.log_test("Liste Sections", False, "R√©ponse n'est pas une liste")
+                    return False
+            else:
+                self.log_test("Liste Sections", False, f"Status: {response.status_code}")
+                return False
+        except Exception as e:
+            self.log_test("Liste Sections", False, f"Erreur: {str(e)}")
+            return False
+    
+    def test_invalid_token(self):
+        """Test avec token invalide"""
+        try:
+            headers = {"Authorization": "Bearer invalid_token_here"}
+            response = requests.get(f"{BASE_URL}/auth/me", headers=headers, timeout=10)
+            
+            if response.status_code == 401:
+                self.log_test("Token Invalide", True, "Token invalide correctement rejet√©")
+                return True
+            else:
+                self.log_test("Token Invalide", False, f"Status attendu: 401, re√ßu: {response.status_code}")
+                return False
+        except Exception as e:
+            self.log_test("Token Invalide", False, f"Erreur: {str(e)}")
+            return False
+    
+    def run_all_tests(self):
+        """Ex√©cute tous les tests dans l'ordre appropri√©"""
+        print("=" * 80)
+        print("TESTS SYST√àME D'AUTHENTIFICATION - ESCADRON DE CADETS")
+        print("=" * 80)
+        print(f"URL de base: {BASE_URL}")
+        print(f"Heure de d√©but: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
+        print()
+        
+        # Tests de base
+        print("üîç TESTS DE BASE")
+        print("-" * 40)
+        self.test_api_health()
+        self.test_invalid_token()
+        self.test_protected_route_without_token()
+        print()
+        
+        # Tests d'authentification
+        print("üîê TESTS D'AUTHENTIFICATION")
+        print("-" * 40)
+        self.test_admin_login()
+        self.test_cadet_login()
+        self.test_invalid_login()
+        self.test_get_current_user_admin()
+        self.test_get_current_user_cadet()
+        print()
+        
+        # Tests syst√®me d'invitation
+        print("üìß TESTS SYST√àME D'INVITATION")
+        print("-" * 40)
+        self.test_create_invitation_admin()
+        self.test_create_invitation_cadet_forbidden()
+        if self.invitation_token:
+            self.test_set_password_with_invitation_token()
+            self.test_login_with_new_account()
+        print()
+        
+        # Tests permissions et gestion utilisateurs
+        print("üë• TESTS GESTION UTILISATEURS")
+        print("-" * 40)
+        self.test_get_users_admin()
+        self.test_get_users_cadet_forbidden()
+        print()
+        
+        # Tests gestion sections
+        print("üìã TESTS GESTION SECTIONS")
+        print("-" * 40)
+        self.test_create_section_admin()
+        self.test_get_sections()
+        print()
+        
+        # R√©sum√© des r√©sultats
+        return self.print_summary()
+    
+    def print_summary(self):
+        """Affiche le r√©sum√© des tests"""
+        print("=" * 80)
+        print("R√âSUM√â DES TESTS")
+        print("=" * 80)
+        
+        total_tests = len(self.test_results)
+        passed_tests = sum(1 for result in self.test_results if result["success"])
+        failed_tests = total_tests - passed_tests
+        
+        print(f"Total des tests: {total_tests}")
+        print(f"Tests r√©ussis: {passed_tests}")
+        print(f"Tests √©chou√©s: {failed_tests}")
+        print(f"Taux de r√©ussite: {(passed_tests/total_tests)*100:.1f}%")
+        print()
+        
+        if failed_tests > 0:
+            print("‚ùå TESTS √âCHOU√âS:")
+            print("-" * 40)
+            for result in self.test_results:
+                if not result["success"]:
+                    print(f"‚Ä¢ {result['test']}: {result['details']}")
+            print()
+        
+        print("‚úÖ TESTS R√âUSSIS:")
+        print("-" * 40)
+        for result in self.test_results:
+            if result["success"]:
+                print(f"‚Ä¢ {result['test']}")
+        
+        print()
+        print(f"Heure de fin: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
+        print("=" * 80)
+        
+        return passed_tests, failed_tests
+
+def main():
+    """Fonction principale"""
+    tester = AuthenticationTester()
+    passed, failed = tester.run_all_tests()
+    
+    # Code de sortie bas√© sur les r√©sultats
+    if failed > 0:
+        print(f"\n‚ö†Ô∏è  {failed} test(s) ont √©chou√©. V√©rifiez les d√©tails ci-dessus.")
+        sys.exit(1)
+    else:
+        print(f"\nüéâ Tous les {passed} tests ont r√©ussi!")
+        sys.exit(0)
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file
diff --git a/model.patch b/model.patch
index 67c0205..60d3176 100644
--- a/model.patch
+++ b/model.patch
@@ -1,14 +0,0 @@
-diff --git a/backend/create_admin.py b/backend/create_admin.py
-index 48573d1..227de5e 100644
---- a/backend/create_admin.py
-+++ b/backend/create_admin.py
-@@ -52,7 +52,7 @@ async def create_admin_user():
-     print("üîê Mot de passe: admin123")
-     print("‚ö†Ô∏è  Changez ce mot de passe en production!")
-     
--    client.close()
-+    await client.close()
- 
- if __name__ == "__main__":
-     asyncio.run(create_admin_user())
-\ No newline at end of file
diff --git a/test_result.md b/test_result.md
index 19ba4a8..f8fa96f 100644
--- a/test_result.md
+++ b/test_result.md
@@ -116,6 +116,9 @@ backend:
         - working: true
           agent: "main"
           comment: "Impl√©ment√© syst√®me complet avec JWT, 4 r√¥les (cadet, cadet_responsible, cadet_admin, encadrement), hashage bcrypt, tokens d'invitation"
+        - working: true
+          agent: "testing"
+          comment: "‚úÖ TEST√â COMPLET - 16/16 tests r√©ussis: Login admin/cadet fonctionnel, tokens JWT valides, permissions par r√¥le correctes, gestion erreurs 401/403 appropri√©e. Admin: admin@escadron.fr, Cadet: cadet.test@escadron.fr"
           
   - task: "API d'invitation par email et d√©finition mot de passe"
     implemented: true  
@@ -128,6 +131,9 @@ backend:
         - working: true
           agent: "main"
           comment: "Admin peut cr√©er invitations, tokens s√©curis√©s 7 jours, utilisateurs d√©finissent mot de passe"
+        - working: true
+          agent: "testing"
+          comment: "‚úÖ TEST√â COMPLET - Syst√®me d'invitation fonctionnel: Admin peut cr√©er invitations, tokens JWT s√©curis√©s 7 jours, d√©finition mot de passe r√©ussie, connexion nouveau compte valid√©e. Permissions correctes (cadet ne peut pas inviter)"
           
   - task: "Gestion des utilisateurs et sections"
     implemented: true
@@ -140,6 +146,9 @@ backend:
         - working: true
           agent: "main"
           comment: "CRUD utilisateurs avec permissions bas√©es sur r√¥les, gestion sections"
+        - working: true
+          agent: "testing"
+          comment: "‚úÖ TEST√â COMPLET - Gestion utilisateurs/sections fonctionnelle: Admin peut lister utilisateurs (4 trouv√©s), cr√©er sections, permissions correctes (cadet ne peut pas acc√©der liste utilisateurs). Toutes les routes prot√©g√©es fonctionnent"
 
 frontend:
   - task: "Interface d'authentification fran√ßaise"
@@ -171,4 +180,6 @@ test_plan:
 
 agent_communication:
     - agent: "main"
-      message: "Phase 1 impl√©ment√©e: syst√®me d'authentification complet backend + frontend. Test√© manuellement avec curl - tous les endpoints fonctionnent. Admin cr√©√©: admin@escadron.fr / admin123. Pr√™t pour tests automatis√©s backend."
\ No newline at end of file
+      message: "Phase 1 impl√©ment√©e: syst√®me d'authentification complet backend + frontend. Test√© manuellement avec curl - tous les endpoints fonctionnent. Admin cr√©√©: admin@escadron.fr / admin123. Pr√™t pour tests automatis√©s backend."
+    - agent: "testing"
+      message: "‚úÖ TESTS BACKEND COMPLETS R√âUSSIS - 16/16 tests pass√©s (100% r√©ussite). Syst√®me d'authentification robuste et s√©curis√©: Login admin/cadet, JWT tokens, permissions par r√¥le, syst√®me d'invitation, gestion utilisateurs/sections. Tous les endpoints fonctionnent parfaitement. Base URL: https://cadetron.preview.emergentagent.com/api. Comptes valid√©s: admin@escadron.fr/admin123, cadet.test@escadron.fr/cadet123. 4 utilisateurs actifs en base."
\ No newline at end of file
